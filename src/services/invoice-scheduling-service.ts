// Invoice Scheduling Service - Story 2.3 Task 3
// Automated invoice generation and delivery scheduling

import { supabase } from '../lib/supabase';
import { Invoice, Student, TherapyProgram, InvoiceItem } from '../types/financial-management';

export interface InvoiceScheduleRule {
  id: string;
  name_ar: string;
  name_en: string;
  description_ar: string;
  description_en: string;
  schedule_type: 'monthly' | 'weekly' | 'session_based' | 'custom';
  frequency: number; // For monthly/weekly schedules
  therapy_program_ids: string[];
  student_ids?: string[];
  generation_day: number; // Day of month for monthly, day of week for weekly
  due_days_offset: number; // Days to add to generation date for due date
  template_id: string;
  is_active: boolean;
  next_generation_date: string;
  created_at: string;
  created_by: string;
}

export interface AutoGeneratedInvoice extends Omit<Invoice, 'id'> {
  schedule_rule_id: string;
  student: Student;
  therapy_programs: TherapyProgram[];
  invoice_items: InvoiceItem[];
}

interface InvoiceGenerationResult {
  success: boolean;
  invoice_id?: string;
  error_message?: string;
  generated_at: string;
}

interface ScheduleRuleExecution {
  rule_id: string;
  execution_date: string;
  invoices_generated: number;
  success_count: number;
  error_count: number;
  errors: Array<{
    student_id: string;
    error_message: string;
  }>;
  next_execution_date: string;
}

export class InvoiceSchedulingService {
  private static instance: InvoiceSchedulingService;

  public static getInstance(): InvoiceSchedulingService {
    if (!InvoiceSchedulingService.instance) {
      InvoiceSchedulingService.instance = new InvoiceSchedulingService();
    }
    return InvoiceSchedulingService.instance;
  }

  private constructor() {}

  /**
   * Create a new invoice schedule rule
   */
  async createScheduleRule(rule: Omit<InvoiceScheduleRule, 'id' | 'created_at' | 'next_generation_date'>): Promise<string> {
    const nextGenerationDate = this.calculateNextGenerationDate(rule.schedule_type, rule.frequency, rule.generation_day);

    const { data, error } = await supabase
      .from('invoice_schedule_rules')
      .insert({
        ...rule,
        next_generation_date: nextGenerationDate,
        created_at: new Date().toISOString()
      })
      .select('id')
      .single();

    if (error) {
      console.error('Error creating schedule rule:', error);
      throw new Error(`Failed to create schedule rule: ${error.message}`);
    }

    return data.id;
  }

  /**
   * Update an existing schedule rule
   */
  async updateScheduleRule(ruleId: string, updates: Partial<InvoiceScheduleRule>): Promise<void> {
    const { error } = await supabase
      .from('invoice_schedule_rules')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', ruleId);

    if (error) {
      console.error('Error updating schedule rule:', error);
      throw new Error(`Failed to update schedule rule: ${error.message}`);
    }
  }

  /**
   * Get all active schedule rules
   */
  async getActiveScheduleRules(): Promise<InvoiceScheduleRule[]> {
    const { data, error } = await supabase
      .from('invoice_schedule_rules')
      .select('*')
      .eq('is_active', true)
      .order('next_generation_date', { ascending: true });

    if (error) {
      console.error('Error fetching schedule rules:', error);
      throw new Error(`Failed to fetch schedule rules: ${error.message}`);
    }

    return data || [];
  }

  /**
   * Get rules that are ready for execution
   */
  async getRulesReadyForExecution(): Promise<InvoiceScheduleRule[]> {
    const now = new Date().toISOString();

    const { data, error } = await supabase
      .from('invoice_schedule_rules')
      .select('*')
      .eq('is_active', true)
      .lte('next_generation_date', now)
      .order('next_generation_date', { ascending: true });

    if (error) {
      console.error('Error fetching ready rules:', error);
      throw new Error(`Failed to fetch ready rules: ${error.message}`);
    }

    return data || [];
  }

  /**
   * Execute a schedule rule and generate invoices
   */
  async executeScheduleRule(ruleId: string): Promise<ScheduleRuleExecution> {
    const execution: ScheduleRuleExecution = {
      rule_id: ruleId,
      execution_date: new Date().toISOString(),
      invoices_generated: 0,
      success_count: 0,
      error_count: 0,
      errors: [],
      next_execution_date: ''
    };

    try {
      // Get the schedule rule
      const { data: rule, error: ruleError } = await supabase
        .from('invoice_schedule_rules')
        .select('*')
        .eq('id', ruleId)
        .single();

      if (ruleError || !rule) {
        throw new Error(`Schedule rule not found: ${ruleError?.message}`);
      }

      // Get eligible students
      const eligibleStudents = await this.getEligibleStudents(rule);
      execution.invoices_generated = eligibleStudents.length;

      // Generate invoices for each eligible student
      for (const student of eligibleStudents) {
        try {
          const invoice = await this.generateInvoiceForStudent(rule, student);
          await this.saveGeneratedInvoice(invoice);
          execution.success_count++;
        } catch (error) {
          execution.error_count++;
          execution.errors.push({
            student_id: student.id,
            error_message: error instanceof Error ? error.message : 'Unknown error'
          });
          console.error(`Error generating invoice for student ${student.id}:`, error);
        }
      }

      // Calculate next execution date
      execution.next_execution_date = this.calculateNextGenerationDate(
        rule.schedule_type,
        rule.frequency,
        rule.generation_day
      );

      // Update the rule with next execution date
      await this.updateScheduleRule(ruleId, {
        next_generation_date: execution.next_execution_date
      });

      // Log the execution
      await this.logScheduleExecution(execution);

    } catch (error) {
      execution.error_count = execution.invoices_generated;
      execution.errors = [{
        student_id: 'system',
        error_message: error instanceof Error ? error.message : 'System error'
      }];
      console.error('Error executing schedule rule:', error);
    }

    return execution;
  }

  /**
   * Process all ready schedule rules
   */
  async processScheduledInvoices(): Promise<ScheduleRuleExecution[]> {
    const readyRules = await this.getRulesReadyForExecution();
    const executions: ScheduleRuleExecution[] = [];

    for (const rule of readyRules) {
      try {
        const execution = await this.executeScheduleRule(rule.id);
        executions.push(execution);
        
        // Add delay between executions to prevent overwhelming the system
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Error processing rule ${rule.id}:`, error);
        executions.push({
          rule_id: rule.id,
          execution_date: new Date().toISOString(),
          invoices_generated: 0,
          success_count: 0,
          error_count: 1,
          errors: [{
            student_id: 'system',
            error_message: error instanceof Error ? error.message : 'Processing error'
          }],
          next_execution_date: rule.next_generation_date
        });
      }
    }

    return executions;
  }

  /**
   * Calculate the next generation date based on schedule type
   */
  private calculateNextGenerationDate(
    scheduleType: string,
    frequency: number,
    generationDay: number
  ): string {
    const now = new Date();
    let nextDate = new Date();

    switch (scheduleType) {
      case 'monthly':
        nextDate = new Date(now.getFullYear(), now.getMonth() + frequency, generationDay);
        if (nextDate <= now) {
          nextDate = new Date(now.getFullYear(), now.getMonth() + frequency + 1, generationDay);
        }
        break;

      case 'weekly':
        const daysToAdd = (generationDay - now.getDay() + 7) % 7;
        nextDate = new Date(now);
        nextDate.setDate(now.getDate() + daysToAdd + (frequency - 1) * 7);
        if (nextDate <= now) {
          nextDate.setDate(nextDate.getDate() + frequency * 7);
        }
        break;

      case 'session_based':
        // For session-based scheduling, we check daily
        nextDate = new Date(now);
        nextDate.setDate(now.getDate() + 1);
        break;

      case 'custom':
        // For custom schedules, use the frequency as days
        nextDate = new Date(now);
        nextDate.setDate(now.getDate() + frequency);
        break;

      default:
        throw new Error(`Unsupported schedule type: ${scheduleType}`);
    }

    return nextDate.toISOString();
  }

  /**
   * Get students eligible for invoice generation based on the rule
   */
  private async getEligibleStudents(rule: InvoiceScheduleRule): Promise<Student[]> {
    let query = supabase
      .from('students')
      .select(`
        *,
        student_enrollments!inner(
          id,
          therapy_program_id,
          enrollment_date,
          status
        )
      `)
      .eq('student_enrollments.status', 'active');

    // Filter by therapy programs
    if (rule.therapy_program_ids.length > 0) {
      query = query.in('student_enrollments.therapy_program_id', rule.therapy_program_ids);
    }

    // Filter by specific students if specified
    if (rule.student_ids && rule.student_ids.length > 0) {
      query = query.in('id', rule.student_ids);
    }

    const { data: students, error } = await query;

    if (error) {
      console.error('Error fetching eligible students:', error);
      throw new Error(`Failed to fetch eligible students: ${error.message}`);
    }

    // For session-based scheduling, check if students have completed sessions
    if (rule.schedule_type === 'session_based') {
      const studentsWithSessions = [];
      
      for (const student of students || []) {
        const hasCompletedSessions = await this.checkCompletedSessions(student.id, rule.frequency);
        if (hasCompletedSessions) {
          studentsWithSessions.push(student);
        }
      }
      
      return studentsWithSessions;
    }

    return students || [];
  }

  /**
   * Check if a student has completed the required number of sessions
   */
  private async checkCompletedSessions(studentId: string, requiredSessions: number): Promise<boolean> {
    const { count, error } = await supabase
      .from('therapy_sessions')
      .select('*', { count: 'exact', head: true })
      .eq('student_id', studentId)
      .eq('session_status', 'completed')
      .gte('session_date', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()); // Last 30 days

    if (error) {
      console.error('Error checking completed sessions:', error);
      return false;
    }

    return (count || 0) >= requiredSessions;
  }

  /**
   * Generate invoice data for a specific student
   */
  private async generateInvoiceForStudent(
    rule: InvoiceScheduleRule,
    student: Student
  ): Promise<AutoGeneratedInvoice> {
    // Get therapy programs for the student
    const { data: programs, error: programsError } = await supabase
      .from('therapy_programs')
      .select('*')
      .in('id', rule.therapy_program_ids);

    if (programsError) {
      throw new Error(`Failed to fetch therapy programs: ${programsError.message}`);
    }

    // Generate invoice items based on programs and recent sessions
    const invoiceItems = await this.generateInvoiceItems(student.id, programs || []);

    // Calculate totals
    const subtotalAmount = invoiceItems.reduce((sum, item) => sum + (item.quantity * item.unit_price), 0);
    const discountAmount = 0; // Could be calculated based on student discounts
    const taxAmount = subtotalAmount * 0.15; // 15% VAT for Saudi Arabia
    const totalAmount = subtotalAmount - discountAmount + taxAmount;

    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + rule.due_days_offset);

    const invoice: AutoGeneratedInvoice = {
      student_id: student.id,
      invoice_number: await this.generateInvoiceNumber(),
      invoice_date: new Date().toISOString(),
      due_date: dueDate.toISOString(),
      subtotal_amount: subtotalAmount,
      discount_amount: discountAmount,
      tax_amount: taxAmount,
      total_amount: totalAmount,
      currency: 'SAR',
      payment_status: 'pending',
      payment_terms: rule.due_days_offset,
      notes_ar: 'فاتورة مُنشأة تلقائياً بناءً على الجدولة المحددة',
      notes_en: 'Auto-generated invoice based on scheduled rule',
      template_id: rule.template_id,
      language_preference: student.preferred_language || 'ar',
      schedule_rule_id: rule.id,
      student: student,
      therapy_programs: programs || [],
      invoice_items: invoiceItems,
      created_at: new Date().toISOString(),
      created_by: 'system'
    };

    return invoice;
  }

  /**
   * Generate invoice items based on student's therapy programs and recent sessions
   */
  private async generateInvoiceItems(studentId: string, programs: TherapyProgram[]): Promise<InvoiceItem[]> {
    const items: InvoiceItem[] = [];

    for (const program of programs) {
      // Get recent sessions for this program
      const { data: sessions, error } = await supabase
        .from('therapy_sessions')
        .select('*')
        .eq('student_id', studentId)
        .eq('therapy_program_id', program.id)
        .eq('session_status', 'completed')
        .gte('session_date', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) // Last 30 days
        .order('session_date', { ascending: true });

      if (error) {
        console.error('Error fetching sessions:', error);
        continue;
      }

      if (sessions && sessions.length > 0) {
        items.push({
          id: crypto.randomUUID(),
          invoice_id: '', // Will be set when invoice is saved
          service_type: 'therapy_session',
          description_ar: `جلسات ${program.name_ar} - ${sessions.length} جلسة`,
          description_en: `${program.name_en} Sessions - ${sessions.length} sessions`,
          quantity: sessions.length,
          unit_price: program.session_price || 0,
          total_price: sessions.length * (program.session_price || 0),
          therapy_program_id: program.id,
          session_ids: sessions.map(s => s.id),
          created_at: new Date().toISOString()
        });
      }
    }

    return items;
  }

  /**
   * Generate a unique invoice number
   */
  private async generateInvoiceNumber(): Promise<string> {
    const year = new Date().getFullYear();
    const month = String(new Date().getMonth() + 1).padStart(2, '0');
    
    // Get the last invoice number for this month
    const { data, error } = await supabase
      .from('invoices')
      .select('invoice_number')
      .like('invoice_number', `INV-${year}${month}-%`)
      .order('created_at', { ascending: false })
      .limit(1);

    let sequenceNumber = 1;

    if (!error && data && data.length > 0) {
      const lastNumber = data[0].invoice_number;
      const lastSequence = parseInt(lastNumber.split('-')[2]);
      sequenceNumber = lastSequence + 1;
    }

    return `INV-${year}${month}-${String(sequenceNumber).padStart(4, '0')}`;
  }

  /**
   * Save the generated invoice to the database
   */
  private async saveGeneratedInvoice(invoice: AutoGeneratedInvoice): Promise<string> {
    // Start a transaction
    const { data: savedInvoice, error: invoiceError } = await supabase
      .from('invoices')
      .insert({
        student_id: invoice.student_id,
        invoice_number: invoice.invoice_number,
        invoice_date: invoice.invoice_date,
        due_date: invoice.due_date,
        subtotal_amount: invoice.subtotal_amount,
        discount_amount: invoice.discount_amount,
        tax_amount: invoice.tax_amount,
        total_amount: invoice.total_amount,
        currency: invoice.currency,
        payment_status: invoice.payment_status,
        payment_terms: invoice.payment_terms,
        notes_ar: invoice.notes_ar,
        notes_en: invoice.notes_en,
        template_id: invoice.template_id,
        language_preference: invoice.language_preference,
        created_at: invoice.created_at,
        created_by: invoice.created_by
      })
      .select('id')
      .single();

    if (invoiceError) {
      throw new Error(`Failed to save invoice: ${invoiceError.message}`);
    }

    // Save invoice items
    const itemsToInsert = invoice.invoice_items.map(item => ({
      ...item,
      invoice_id: savedInvoice.id
    }));

    const { error: itemsError } = await supabase
      .from('invoice_items')
      .insert(itemsToInsert);

    if (itemsError) {
      // Try to clean up the invoice if items failed
      await supabase.from('invoices').delete().eq('id', savedInvoice.id);
      throw new Error(`Failed to save invoice items: ${itemsError.message}`);
    }

    return savedInvoice.id;
  }

  /**
   * Log schedule execution results
   */
  private async logScheduleExecution(execution: ScheduleRuleExecution): Promise<void> {
    const { error } = await supabase
      .from('invoice_schedule_executions')
      .insert({
        rule_id: execution.rule_id,
        execution_date: execution.execution_date,
        invoices_generated: execution.invoices_generated,
        success_count: execution.success_count,
        error_count: execution.error_count,
        errors: execution.errors,
        next_execution_date: execution.next_execution_date
      });

    if (error) {
      console.error('Error logging schedule execution:', error);
      // Don't throw here as the main operation succeeded
    }
  }

  /**
   * Get execution history for a schedule rule
   */
  async getExecutionHistory(ruleId: string, limit: number = 10): Promise<ScheduleRuleExecution[]> {
    const { data, error } = await supabase
      .from('invoice_schedule_executions')
      .select('*')
      .eq('rule_id', ruleId)
      .order('execution_date', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error fetching execution history:', error);
      throw new Error(`Failed to fetch execution history: ${error.message}`);
    }

    return data || [];
  }

  /**
   * Cancel/deactivate a schedule rule
   */
  async deactivateScheduleRule(ruleId: string): Promise<void> {
    await this.updateScheduleRule(ruleId, { is_active: false });
  }

  /**
   * Reactivate a schedule rule
   */
  async reactivateScheduleRule(ruleId: string): Promise<void> {
    const nextGenerationDate = new Date();
    nextGenerationDate.setDate(nextGenerationDate.getDate() + 1); // Start tomorrow

    await this.updateScheduleRule(ruleId, {
      is_active: true,
      next_generation_date: nextGenerationDate.toISOString()
    });
  }
}

// Export convenience functions
export const createInvoiceScheduleRule = async (
  rule: Omit<InvoiceScheduleRule, 'id' | 'created_at' | 'next_generation_date'>
): Promise<string> => {
  const service = InvoiceSchedulingService.getInstance();
  return service.createScheduleRule(rule);
};

export const processScheduledInvoices = async (): Promise<ScheduleRuleExecution[]> => {
  const service = InvoiceSchedulingService.getInstance();
  return service.processScheduledInvoices();
};

export const getActiveScheduleRules = async (): Promise<InvoiceScheduleRule[]> => {
  const service = InvoiceSchedulingService.getInstance();
  return service.getActiveScheduleRules();
};

export default InvoiceSchedulingService;