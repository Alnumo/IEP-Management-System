// Tests for Media Upload Service
// Story 1.3: Media-Rich Progress Documentation Workflow

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { 
  MediaUploadService, 
  validateFile, 
  getMediaTypeFromMimeType,
  defaultUploadConfig 
} from './mediaUploadService'
import { supabase } from '@/lib/supabase'
import type { CreateSessionMediaDto, MediaUploadConfig } from '@/types/media'

// Mock Supabase with proper query chain
vi.mock('@/lib/supabase', () => {
  const mockQuery = {
    insert: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    single: vi.fn(),
    delete: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    upsert: vi.fn().mockReturnThis()
  }

  return {
    supabase: {
      storage: {
        from: vi.fn(() => ({
          upload: vi.fn(),
          getPublicUrl: vi.fn(),
          remove: vi.fn()
        }))
      },
      from: vi.fn(() => mockQuery)
    },
    mockQuery
  }
})

// Mock file objects
const createMockFile = (name: string, type: string, size: number): File => {
  const file = new File(['mock content'], name, { type })
  Object.defineProperty(file, 'size', { value: size, writable: false })
  return file
}

// Mock URL.createObjectURL and URL.revokeObjectURL
Object.defineProperty(global.URL, 'createObjectURL', {
  writable: true,
  value: vi.fn(() => 'mock-object-url')
})

Object.defineProperty(global.URL, 'revokeObjectURL', {
  writable: true,
  value: vi.fn()
})

// Mock Image constructor for browser APIs
global.Image = vi.fn(() => {
  const img = {
    onload: null as any,
    onerror: null as any,
    width: 1920,
    height: 1080,
    _src: '',
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    set src(value: string) {
      this._src = value
      // Simulate async image loading
      setTimeout(() => {
        if (this.onload) {
          this.onload()
        }
      }, 0)
    },
    get src() {
      return this._src
    }
  }
  return img
}) as any

// Mock HTMLCanvasElement and CanvasRenderingContext2D
global.HTMLCanvasElement = vi.fn(() => ({
  getContext: vi.fn(() => ({
    drawImage: vi.fn(),
    canvas: {
      toBlob: vi.fn((callback: any) => {
        // Simulate successful blob creation
        const mockBlob = new Blob(['mock'], { type: 'image/jpeg' })
        callback(mockBlob)
      }),
      width: 1920,
      height: 1080
    }
  })),
  width: 1920,
  height: 1080
})) as any

// Mock fetch for thumbnail operations
global.fetch = vi.fn().mockResolvedValue({
  blob: () => Promise.resolve(new Blob(['mock'], { type: 'image/jpeg' }))
})

// Mock document.createElement for canvas
Object.defineProperty(global, 'document', {
  writable: true,
  value: {
    createElement: vi.fn((tagName: string) => {
      if (tagName === 'canvas') {
        return new global.HTMLCanvasElement()
      }
      return {}
    })
  }
})

// Mock Canvas and Image for compression tests
class MockCanvas {
  width = 0
  height = 0
  
  getContext() {
    return {
      drawImage: vi.fn(),
      canvas: this
    }
  }
  
  toBlob(callback: (blob: Blob | null) => void) {
    callback(new Blob(['compressed'], { type: 'image/jpeg' }))
  }
}

class MockImage {
  onload: (() => void) | null = null
  onerror: (() => void) | null = null
  width = 1920
  height = 1080
  
  set src(_: string) {
    setTimeout(() => this.onload?.(), 0)
  }
}

Object.defineProperty(global, 'Image', {
  value: MockImage
})

Object.defineProperty(document, 'createElement', {
  value: (tagName: string) => {
    if (tagName === 'canvas') {
      return new MockCanvas()
    }
    return document.createElement(tagName)
  }
})

describe('validateFile', () => {
  it('should validate file size within limits', () => {
    const file = createMockFile('test.jpg', 'image/jpeg', 1024 * 1024) // 1MB
    const result = validateFile(file, defaultUploadConfig)
    
    expect(result.valid).toBe(true)
    expect(result.error).toBeUndefined()
  })

  it('should reject files exceeding size limit', () => {
    const file = createMockFile('large.jpg', 'image/jpeg', 100 * 1024 * 1024) // 100MB
    const result = validateFile(file, defaultUploadConfig)
    
    expect(result.valid).toBe(false)
    expect(result.error).toContain('File size exceeds')
  })

  it('should validate allowed file types', () => {
    const validFile = createMockFile('test.jpg', 'image/jpeg', 1024)
    const invalidFile = createMockFile('test.exe', 'application/exe', 1024)
    
    expect(validateFile(validFile, defaultUploadConfig).valid).toBe(true)
    expect(validateFile(invalidFile, defaultUploadConfig).valid).toBe(false)
  })

  it('should work with custom config', () => {
    const customConfig: MediaUploadConfig = {
      max_file_size: 5 * 1024 * 1024, // 5MB
      allowed_file_types: ['image/png'],
      chunk_size: 1024,
      concurrent_uploads: 1,
      compression_enabled: false,
      thumbnail_generation: false
    }

    const file = createMockFile('test.png', 'image/png', 3 * 1024 * 1024)
    expect(validateFile(file, customConfig).valid).toBe(true)

    const jpegFile = createMockFile('test.jpg', 'image/jpeg', 1024)
    expect(validateFile(jpegFile, customConfig).valid).toBe(false)
  })
})

describe('getMediaTypeFromMimeType', () => {
  it('should correctly identify image files', () => {
    expect(getMediaTypeFromMimeType('image/jpeg')).toBe('photo')
    expect(getMediaTypeFromMimeType('image/png')).toBe('photo')
    expect(getMediaTypeFromMimeType('image/gif')).toBe('photo')
  })

  it('should correctly identify video files', () => {
    expect(getMediaTypeFromMimeType('video/mp4')).toBe('video')
    expect(getMediaTypeFromMimeType('video/avi')).toBe('video')
    expect(getMediaTypeFromMimeType('video/quicktime')).toBe('video')
  })

  it('should correctly identify audio files', () => {
    expect(getMediaTypeFromMimeType('audio/mpeg')).toBe('audio')
    expect(getMediaTypeFromMimeType('audio/wav')).toBe('audio')
    expect(getMediaTypeFromMimeType('audio/ogg')).toBe('audio')
  })

  it('should default to document for unknown types', () => {
    expect(getMediaTypeFromMimeType('application/pdf')).toBe('document')
    expect(getMediaTypeFromMimeType('text/plain')).toBe('document')
    expect(getMediaTypeFromMimeType('unknown/type')).toBe('document')
  })
})

describe('MediaUploadService', () => {
  let service: MediaUploadService
  let mockUpload: any
  let mockGetPublicUrl: any
  let mockInsert: any
  let mockSingle: any
  let mockStorage: any

  beforeEach(async () => {
    service = new MediaUploadService()
    vi.clearAllMocks()
    
    mockUpload = vi.fn().mockResolvedValue({
      data: { path: 'students/student1/sessions/session1/1672531200000_test.jpg' },
      error: null
    })
    
    mockGetPublicUrl = vi.fn().mockReturnValue({
      data: { publicUrl: 'https://storage.supabase.co/test.jpg' }
    })

    mockSingle = vi.fn().mockResolvedValue({
      data: {
        id: 'media-id-1',
        student_id: 'student1',
        file_url: 'https://storage.supabase.co/test.jpg'
      },
      error: null
    })

    mockStorage = {
      upload: mockUpload,
      getPublicUrl: mockGetPublicUrl,
      remove: vi.fn().mockResolvedValue({ error: null })
    }

    // Reset and configure mocks properly
    const { mockQuery } = await vi.importMock('@/lib/supabase')
    mockQuery.single.mockImplementation(() => mockSingle())
    mockQuery.insert.mockReturnValue(mockQuery)
    mockQuery.select.mockReturnValue(mockQuery)
    mockQuery.delete.mockReturnValue(mockQuery)
    mockQuery.eq.mockReturnValue(mockQuery)
    mockQuery.update.mockReturnValue(mockQuery)
    mockQuery.upsert.mockReturnValue(mockQuery)

    vi.mocked(supabase.storage.from).mockReturnValue(mockStorage)
    vi.mocked(supabase.from).mockReturnValue(mockQuery)
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  describe('uploadFile', () => {
    it('should upload a file successfully', async () => {
      const file = createMockFile('test.jpg', 'image/jpeg', 1024 * 1024)
      const params = {
        studentId: 'student1',
        sessionId: 'session1',
        uploadType: 'session_documentation' as const,
        captionAr: 'صورة تجريبية',
        captionEn: 'Test image'
      }

      const result = await service.uploadFile(file, params)

      expect(mockUpload).toHaveBeenCalled()
      expect(mockGetPublicUrl).toHaveBeenCalled()
      expect(result.id).toBe('media-id-1')
    }, 15000)

    it('should handle file validation errors', async () => {
      const file = createMockFile('test.exe', 'application/exe', 1024)
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      await expect(service.uploadFile(file, params)).rejects.toThrow('File type')
    })

    it('should handle storage upload errors', async () => {
      mockUpload.mockResolvedValue({
        data: null,
        error: { message: 'Storage upload failed' }
      })

      const file = createMockFile('test.jpg', 'image/jpeg', 1024)
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      await expect(service.uploadFile(file, params)).rejects.toThrow('Upload failed')
    })

    it('should handle database insert errors and cleanup storage', async () => {
      mockSingle.mockResolvedValue({
        data: null,
        error: { message: 'Database insert failed' }
      })

      const file = createMockFile('test.jpg', 'image/jpeg', 1024)
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      await expect(service.uploadFile(file, params)).rejects.toThrow('Database insert failed')
      expect(mockStorage.remove).toHaveBeenCalled()
    })

    it('should call progress callback during upload', async () => {
      const progressCallback = vi.fn()
      const file = createMockFile('test.jpg', 'image/jpeg', 1024)
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      await service.uploadFile(file, params, progressCallback)

      expect(progressCallback).toHaveBeenCalled()
      const calls = progressCallback.mock.calls
      expect(calls.some(call => call[0].status === 'uploading')).toBe(true)
      expect(calls.some(call => call[0].status === 'completed')).toBe(true)
    })

    it('should generate thumbnails for images when enabled', async () => {
      const customService = new MediaUploadService({ thumbnail_generation: true })
      const file = createMockFile('test.jpg', 'image/jpeg', 1024)
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      await customService.uploadFile(file, params)

      // Should have called upload twice - once for original, once for thumbnail
      expect(mockUpload).toHaveBeenCalledTimes(2)
    })

    it('should compress images when compression is enabled', async () => {
      const customService = new MediaUploadService({ compression_enabled: true })
      const file = createMockFile('test.jpg', 'image/jpeg', 10 * 1024 * 1024) // 10MB
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      await customService.uploadFile(file, params)

      expect(mockUpload).toHaveBeenCalled()
      // Compression should have been applied
    })

    it('should include all optional parameters in database record', async () => {
      const file = createMockFile('test.jpg', 'image/jpeg', 1024)
      const params = {
        studentId: 'student1',
        sessionId: 'session1',
        uploadType: 'session_documentation' as const,
        captionAr: 'صورة تجريبية',
        captionEn: 'Test image',
        descriptionAr: 'وصف مفصل',
        descriptionEn: 'Detailed description',
        tags: ['test', 'image'],
        isPrivate: true,
        isFeatured: true
      }

      await service.uploadFile(file, params)

      const insertCall = mockInsert.mock.calls[0][0]
      expect(insertCall.caption_ar).toBe('صورة تجريبية')
      expect(insertCall.caption_en).toBe('Test image')
      expect(insertCall.description_ar).toBe('وصف مفصل')
      expect(insertCall.description_en).toBe('Detailed description')
      expect(insertCall.tags).toEqual(['test', 'image'])
      expect(insertCall.is_private).toBe(true)
      expect(insertCall.is_featured).toBe(true)
    })
  })

  describe('uploadFiles (batch)', () => {
    it('should upload multiple files successfully', async () => {
      const files = [
        createMockFile('test1.jpg', 'image/jpeg', 1024),
        createMockFile('test2.jpg', 'image/jpeg', 2048)
      ]
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      mockSingle
        .mockResolvedValueOnce({
          data: { id: 'media-1', file_name: 'test1.jpg' },
          error: null
        })
        .mockResolvedValueOnce({
          data: { id: 'media-2', file_name: 'test2.jpg' },
          error: null
        })

      const result = await service.uploadFiles(files, params)

      expect(result.completed).toHaveLength(2)
      expect(result.failed).toHaveLength(0)
      expect(mockUpload).toHaveBeenCalledTimes(2)
    })

    it('should handle partial failures gracefully', async () => {
      const files = [
        createMockFile('valid.jpg', 'image/jpeg', 1024),
        createMockFile('invalid.exe', 'application/exe', 1024)
      ]
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      mockSingle.mockResolvedValue({
        data: { id: 'media-1', file_name: 'valid.jpg' },
        error: null
      })

      const result = await service.uploadFiles(files, params)

      expect(result.completed).toHaveLength(1)
      expect(result.failed).toHaveLength(1)
      expect(result.failed[0].file.name).toBe('invalid.exe')
    })

    it('should respect concurrency limits', async () => {
      const customService = new MediaUploadService({ concurrent_uploads: 1 })
      const files = Array.from({ length: 5 }, (_, i) => 
        createMockFile(`test${i}.jpg`, 'image/jpeg', 1024)
      )
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      mockSingle.mockResolvedValue({
        data: { id: 'media-id' },
        error: null
      })

      await customService.uploadFiles(files, params)

      // With concurrency limit of 1, files should be processed sequentially
      expect(mockUpload).toHaveBeenCalledTimes(5)
    })

    it('should call progress callback with batch updates', async () => {
      const progressCallback = vi.fn()
      const files = [
        createMockFile('test1.jpg', 'image/jpeg', 1024),
        createMockFile('test2.jpg', 'image/jpeg', 2048)
      ]
      const params = {
        studentId: 'student1',
        uploadType: 'session_documentation' as const
      }

      mockSingle.mockResolvedValue({
        data: { id: 'media-id' },
        error: null
      })

      await service.uploadFiles(files, params, progressCallback)

      expect(progressCallback).toHaveBeenCalled()
      const calls = progressCallback.mock.calls
      expect(calls.length).toBeGreaterThan(0)
    })
  })

  describe('deleteMedia', () => {
    it('should delete media and associated files', async () => {
      const mockSelect = vi.fn().mockResolvedValue({
        data: {
          file_url: 'https://storage.supabase.co/students/student1/media/test.jpg',
          thumbnail_url: 'https://storage.supabase.co/students/student1/media/test_thumbnail'
        },
        error: null
      })

      const mockDelete = vi.fn().mockResolvedValue({
        error: null
      })

      vi.mocked(supabase.from).mockReturnValue({
        select: mockSelect,
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockReturnValue(Promise.resolve({ data: {}, error: null })),
        delete: mockDelete,
        insert: vi.fn(),
        update: vi.fn()
      })

      await service.deleteMedia('media-id-1')

      expect(mockSelect).toHaveBeenCalled()
      expect(mockStorage.remove).toHaveBeenCalled()
      expect(mockDelete).toHaveBeenCalled()
    })

    it('should handle delete errors gracefully', async () => {
      const mockSelect = vi.fn().mockResolvedValue({
        data: null,
        error: { message: 'Media not found' }
      })

      vi.mocked(supabase.from).mockReturnValue({
        select: mockSelect,
        eq: vi.fn().mockReturnThis(),
        single: vi.fn(),
        delete: vi.fn(),
        insert: vi.fn(),
        update: vi.fn()
      })

      await expect(service.deleteMedia('nonexistent')).rejects.toThrow('Failed to fetch')
    })

    it('should continue with database deletion even if storage deletion fails', async () => {
      const mockSelect = vi.fn().mockResolvedValue({
        data: { file_url: 'https://storage.supabase.co/test.jpg' },
        error: null
      })

      const mockDelete = vi.fn().mockResolvedValue({
        error: null
      })

      mockStorage.remove.mockResolvedValue({
        error: { message: 'Storage delete failed' }
      })

      vi.mocked(supabase.from).mockReturnValue({
        select: mockSelect,
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockReturnValue(Promise.resolve({ data: {}, error: null })),
        delete: mockDelete,
        insert: vi.fn(),
        update: vi.fn()
      })

      // Should not throw error despite storage failure
      await service.deleteMedia('media-id-1')
      expect(mockDelete).toHaveBeenCalled()
    })
  })

  describe('Progress tracking', () => {
    it('should track upload progress correctly', () => {
      const uploadId = service.getUploadProgress('test-id')
      expect(uploadId).toBeUndefined()

      // Progress tracking is tested through uploadFile method
    })

    it('should allow subscription to progress updates', () => {
      const callback = vi.fn()
      service.subscribeToProgress('test-id', callback)
      service.unsubscribeFromProgress('test-id')
      
      // Subscription system is internal - test through upload operations
    })

    it('should cancel uploads correctly', async () => {
      await service.cancelUpload('test-id')
      // Cancel operation should not throw errors
    })
  })
})

describe('Edge cases and error handling', () => {
  it('should handle empty file uploads', async () => {
    const service = new MediaUploadService()
    const file = createMockFile('empty.txt', 'text/plain', 0)
    const params = {
      studentId: 'student1',
      uploadType: 'session_documentation' as const
    }

    // Empty files should be handled gracefully
    await expect(service.uploadFile(file, params)).rejects.toThrow()
  })

  it('should handle very long file names', () => {
    const longName = 'a'.repeat(300) + '.jpg'
    const file = createMockFile(longName, 'image/jpeg', 1024)
    
    const result = validateFile(file, defaultUploadConfig)
    expect(result.valid).toBe(true)
  })

  it('should handle files with no extension', () => {
    const file = createMockFile('no_extension', 'image/jpeg', 1024)
    const result = validateFile(file, defaultUploadConfig)
    expect(result.valid).toBe(true)
  })

  it('should handle special characters in file names', () => {
    const specialName = 'test-file_with@special#chars$.jpg'
    const file = createMockFile(specialName, 'image/jpeg', 1024)
    const result = validateFile(file, defaultUploadConfig)
    expect(result.valid).toBe(true)
  })
})