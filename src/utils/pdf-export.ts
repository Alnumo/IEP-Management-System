import jsPDF from 'jspdf' // Used in IEPPDFExporter constructor
import 'jspdf-autotable'
import { format } from 'date-fns'
import { ar } from 'date-fns/locale'
import type { IEP, IEPGoal, Student, IEPProgressData } from '@/types/iep'

// Extend jsPDF type to include autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (config: any) => void
    lastAutoTable?: {
      finalY: number
    }
  }
}

export interface ExportOptions {
  language: 'en' | 'ar' | 'bilingual'
  includeProgress: boolean
  includeMeetings: boolean
  includeGoalDetails: boolean
  includeAssessments: boolean
  dateRange?: {
    start: string
    end: string
  }
  watermark?: string
  confidential?: boolean
}

export interface PDFExportData {
  iep: IEP & {
    student: Student
    goals: IEPGoal[]
    progress_data?: IEPProgressData[]
  }
  exportOptions: ExportOptions
  generatedBy: string
  generatedAt: string
}

// Arabic font configuration for proper RTL support
// Note: In production, you would load Arabic fonts for proper RTL support
// const FONTS = {
//   arabic: { normal: 'fonts/NotoSansArabic-Regular.ttf', bold: 'fonts/NotoSansArabic-Bold.ttf' },
//   english: { normal: 'Helvetica', bold: 'Helvetica-Bold' }
// }

// Color scheme for professional IEP documents
const COLORS = {
  primary: '#2563eb', // Blue
  secondary: '#64748b', // Slate
  success: '#22c55e', // Green
  warning: '#f59e0b', // Amber
  danger: '#ef4444', // Red
  text: '#1f2937', // Gray-800
  lightText: '#6b7280', // Gray-500
  border: '#e5e7eb', // Gray-200
  background: '#f9fafb' // Gray-50
}

// Translation mappings for bilingual support
const TRANSLATIONS = {
  en: {
    title: 'Individual Education Program (IEP)',
    studentInfo: 'Student Information',
    programInfo: 'Program Information',
    goals: 'IEP Goals',
    progress: 'Progress Data',
    meetings: 'Meeting History',
    assessments: 'Assessments',
    services: 'Special Education Services',
    accommodations: 'Accommodations & Modifications',
    confidential: 'CONFIDENTIAL DOCUMENT',
    generatedOn: 'Generated on',
    generatedBy: 'Generated by',
    page: 'Page',
    of: 'of',
    name: 'Name',
    studentId: 'Student ID',
    dateOfBirth: 'Date of Birth',
    grade: 'Grade Level',
    disability: 'Primary Disability',
    startDate: 'IEP Start Date',
    endDate: 'IEP End Date',
    lastReview: 'Last Annual Review',
    nextReview: 'Next Review Due',
    goalTitle: 'Goal',
    measurableObjective: 'Measurable Objective',
    progressStatus: 'Progress Status',
    dataCollection: 'Data Collection',
    mastered: 'Mastered',
    progressing: 'Progressing',
    introduced: 'Introduced',
    notStarted: 'Not Started',
    meetingType: 'Meeting Type',
    meetingDate: 'Meeting Date',
    attendees: 'Attendees',
    decisions: 'Decisions Made',
    followUp: 'Follow-up Actions'
  },
  ar: {
    title: 'البرنامج التعليمي الفردي',
    studentInfo: 'معلومات الطالب',
    programInfo: 'معلومات البرنامج',
    goals: 'أهداف البرنامج التعليمي الفردي',
    progress: 'بيانات التقدم',
    meetings: 'تاريخ الاجتماعات',
    assessments: 'التقييمات',
    services: 'خدمات التربية الخاصة',
    accommodations: 'التسهيلات والتعديلات',
    confidential: 'وثيقة سرية',
    generatedOn: 'تم الإنشاء في',
    generatedBy: 'تم الإنشاء بواسطة',
    page: 'صفحة',
    of: 'من',
    name: 'الاسم',
    studentId: 'رقم الطالب',
    dateOfBirth: 'تاريخ الميلاد',
    grade: 'الصف الدراسي',
    disability: 'الإعاقة الأساسية',
    startDate: 'تاريخ بداية البرنامج',
    endDate: 'تاريخ نهاية البرنامج',
    lastReview: 'آخر مراجعة سنوية',
    nextReview: 'المراجعة التالية مستحقة',
    goalTitle: 'الهدف',
    measurableObjective: 'الهدف القابل للقياس',
    progressStatus: 'حالة التقدم',
    dataCollection: 'جمع البيانات',
    mastered: 'مُتقن',
    progressing: 'يتقدم',
    introduced: 'تم التعريف',
    notStarted: 'لم يبدأ',
    meetingType: 'نوع الاجتماع',
    meetingDate: 'تاريخ الاجتماع',
    attendees: 'الحضور',
    decisions: 'القرارات المتخذة',
    followUp: 'إجراءات المتابعة'
  }
}

class IEPPDFExporter {
  private doc: jsPDF
  private options: ExportOptions
  private data: PDFExportData
  private currentY: number = 20
  private pageWidth: number = 210 // A4 width in mm
  private pageHeight: number = 297 // A4 height in mm
  private margin: number = 20

  constructor(data: PDFExportData) {
    this.data = data
    this.options = data.exportOptions
    this.doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    })
    
    // Set up fonts for proper multilingual support
    this.setupFonts()
    this.currentY = this.margin
  }

  private setupFonts() {
    // In a real implementation, you would load Arabic fonts
    // For now, we'll use Unicode-friendly fonts
    this.doc.setFont('helvetica')
  }

  private getTranslation(key: string, lang: 'en' | 'ar' = 'en'): string {
    return TRANSLATIONS[lang][key as keyof typeof TRANSLATIONS.en] || key
  }

  private addHeader() {
    const { language, confidential } = this.options
    
    // Add confidentiality notice if required
    if (confidential) {
      this.doc.setFontSize(12)
      this.doc.setTextColor(COLORS.danger)
      this.doc.setFont('helvetica', 'bold')
      
      if (language === 'ar' || language === 'bilingual') {
        this.doc.text(this.getTranslation('confidential', 'ar'), this.pageWidth - this.margin, this.currentY, { align: 'right' })
        this.currentY += 8
      }
      
      if (language === 'en' || language === 'bilingual') {
        this.doc.text(this.getTranslation('confidential', 'en'), this.margin, this.currentY, { align: 'left' })
        this.currentY += 8
      }
    }

    // Main title
    this.doc.setFontSize(18)
    this.doc.setTextColor(COLORS.primary)
    this.doc.setFont('helvetica', 'bold')

    if (language === 'ar' || language === 'bilingual') {
      this.doc.text(this.getTranslation('title', 'ar'), this.pageWidth - this.margin, this.currentY, { align: 'right' })
      this.currentY += 12
    }

    if (language === 'en' || language === 'bilingual') {
      this.doc.text(this.getTranslation('title', 'en'), this.margin, this.currentY)
      this.currentY += 12
    }

    this.addLine()
  }

  private addFooter(pageNumber: number, totalPages: number) {
    const footerY = this.pageHeight - 15
    
    this.doc.setFontSize(8)
    this.doc.setTextColor(COLORS.lightText)
    this.doc.setFont('helvetica', 'normal')

    // Page numbers
    const pageText = `${this.getTranslation('page')} ${pageNumber} ${this.getTranslation('of')} ${totalPages}`
    this.doc.text(pageText, this.pageWidth / 2, footerY, { align: 'center' })

    // Generation info
    const generationInfo = `${this.getTranslation('generatedOn')}: ${this.data.generatedAt} | ${this.getTranslation('generatedBy')}: ${this.data.generatedBy}`
    this.doc.text(generationInfo, this.margin, footerY)
  }

  private addLine() {
    this.doc.setDrawColor(COLORS.border)
    this.doc.line(this.margin, this.currentY, this.pageWidth - this.margin, this.currentY)
    this.currentY += 8
  }

  private addSectionHeader(titleEn: string, titleAr?: string) {
    const { language } = this.options
    
    this.doc.setFontSize(14)
    this.doc.setTextColor(COLORS.primary)
    this.doc.setFont('helvetica', 'bold')

    if (language === 'ar' && titleAr) {
      this.doc.text(titleAr, this.pageWidth - this.margin, this.currentY, { align: 'right' })
      this.currentY += 8
    }

    if (language === 'en' || language === 'bilingual') {
      this.doc.text(titleEn, this.margin, this.currentY)
      this.currentY += 8
    }

    if (language === 'bilingual' && titleAr) {
      this.doc.text(titleAr, this.pageWidth - this.margin, this.currentY, { align: 'right' })
      this.currentY += 8
    }

    this.addLine()
  }

  private addStudentInformation() {
    const { student } = this.data.iep
    const { language } = this.options

    this.addSectionHeader('Student Information', 'معلومات الطالب')

    const studentData = [
      [this.getTranslation('name'), `${student.first_name} ${student.last_name}`],
      [this.getTranslation('studentId'), student.student_id],
      [this.getTranslation('dateOfBirth'), format(new Date(student.date_of_birth), 'PPP', { locale: language === 'ar' ? ar : undefined })],
      [this.getTranslation('grade'), student.current_grade || 'N/A'],
      [this.getTranslation('disability'), student.primary_disability || 'N/A']
    ]

    this.doc.autoTable({
      startY: this.currentY,
      body: studentData,
      theme: 'grid',
      styles: {
        fontSize: 10,
        cellPadding: 3
      },
      columnStyles: {
        0: { fontStyle: 'bold', fillColor: COLORS.background },
        1: { textColor: COLORS.text }
      }
    })

    this.currentY = this.doc.lastAutoTable?.finalY ? this.doc.lastAutoTable.finalY + 10 : this.currentY + 60
  }

  private addProgramInformation() {
    const { iep } = this.data
    const { language } = this.options

    this.addSectionHeader('Program Information', 'معلومات البرنامج')

    const programData = [
      [this.getTranslation('startDate'), format(new Date(iep.start_date), 'PPP', { locale: language === 'ar' ? ar : undefined })],
      [this.getTranslation('endDate'), format(new Date(iep.end_date), 'PPP', { locale: language === 'ar' ? ar : undefined })],
      [this.getTranslation('lastReview'), iep.last_annual_review ? format(new Date(iep.last_annual_review), 'PPP', { locale: language === 'ar' ? ar : undefined }) : 'N/A'],
      ['Program Type', iep.program_type],
      ['Placement', iep.placement || 'General Education']
    ]

    this.doc.autoTable({
      startY: this.currentY,
      body: programData,
      theme: 'grid',
      styles: {
        fontSize: 10,
        cellPadding: 3
      },
      columnStyles: {
        0: { fontStyle: 'bold', fillColor: COLORS.background },
        1: { textColor: COLORS.text }
      }
    })

    this.currentY = this.doc.lastAutoTable?.finalY ? this.doc.lastAutoTable.finalY + 10 : this.currentY + 60
  }

  private addGoals() {
    const { goals } = this.data.iep
    const { includeGoalDetails } = this.options

    if (!goals || goals.length === 0) return

    this.addSectionHeader('IEP Goals', 'أهداف البرنامج التعليمي الفردي')

    goals.forEach((goal, index) => {
      if (this.currentY > this.pageHeight - 50) {
        this.doc.addPage()
        this.currentY = this.margin
      }

      // Goal header
      this.doc.setFontSize(12)
      this.doc.setTextColor(COLORS.text)
      this.doc.setFont('helvetica', 'bold')
      this.doc.text(`${this.getTranslation('goalTitle')} ${index + 1}:`, this.margin, this.currentY)
      this.currentY += 8

      // Goal description
      this.doc.setFont('helvetica', 'normal')
      this.doc.setFontSize(10)
      const goalText = goal.goal_text || 'No description available'
      const splitText = this.doc.splitTextToSize(goalText, this.pageWidth - (2 * this.margin))
      this.doc.text(splitText, this.margin + 5, this.currentY)
      this.currentY += splitText.length * 5 + 8

      if (includeGoalDetails) {
        // Measurable objective
        if (goal.measurable_objective) {
          this.doc.setFont('helvetica', 'bold')
          this.doc.text(`${this.getTranslation('measurableObjective')}:`, this.margin + 5, this.currentY)
          this.currentY += 6
          this.doc.setFont('helvetica', 'normal')
          const objectiveText = this.doc.splitTextToSize(goal.measurable_objective, this.pageWidth - (2 * this.margin) - 10)
          this.doc.text(objectiveText, this.margin + 10, this.currentY)
          this.currentY += objectiveText.length * 5 + 8
        }

        // Progress status
        this.doc.setFont('helvetica', 'bold')
        this.doc.text(`${this.getTranslation('progressStatus')}:`, this.margin + 5, this.currentY)
        this.doc.setFont('helvetica', 'normal')
        
        const statusColor = this.getStatusColor(goal.current_status)
        this.doc.setTextColor(statusColor)
        this.doc.text(this.getTranslation(goal.current_status || 'notStarted'), this.margin + 45, this.currentY)
        this.doc.setTextColor(COLORS.text)
        this.currentY += 10
      }

      this.addLine()
    })
  }

  private addProgressData() {
    const { progress_data } = this.data.iep
    const { includeProgress, dateRange } = this.options

    if (!includeProgress || !progress_data || progress_data.length === 0) return

    let filteredData = progress_data
    if (dateRange) {
      filteredData = progress_data.filter(data => {
        const dataDate = new Date(data.collection_date)
        return dataDate >= new Date(dateRange.start) && dataDate <= new Date(dateRange.end)
      })
    }

    if (filteredData.length === 0) return

    this.addSectionHeader('Progress Data', 'بيانات التقدم')

    const progressTableData = filteredData.map(data => [
      format(new Date(data.collection_date), 'PP'),
      data.goal_id || 'General',
      this.getTranslation(data.status || 'notStarted'),
      data.data_value?.toString() || 'N/A',
      data.notes || ''
    ])

    this.doc.autoTable({
      head: [[
        'Date',
        'Goal',
        'Status', 
        'Value',
        'Notes'
      ]],
      body: progressTableData,
      startY: this.currentY,
      theme: 'striped',
      styles: {
        fontSize: 9,
        cellPadding: 2
      },
      headStyles: {
        fillColor: COLORS.primary,
        textColor: '#ffffff'
      },
      columnStyles: {
        0: { cellWidth: 25 },
        1: { cellWidth: 30 },
        2: { cellWidth: 25 },
        3: { cellWidth: 20 },
        4: { cellWidth: 'auto' }
      }
    })

    this.currentY = this.doc.lastAutoTable?.finalY ? this.doc.lastAutoTable.finalY + 10 : this.currentY + 60
  }

  private addServices() {
    const { services, accommodations } = this.data.iep

    if (!services && !accommodations) return

    this.addSectionHeader('Services & Accommodations', 'الخدمات والتسهيلات')

    if (services && Array.isArray(services) && services.length > 0) {
      this.doc.setFontSize(12)
      this.doc.setFont('helvetica', 'bold')
      this.doc.text(this.getTranslation('services'), this.margin, this.currentY)
      this.currentY += 8

      services.forEach((service: any) => {
        this.doc.setFontSize(10)
        this.doc.setFont('helvetica', 'normal')
        this.doc.text(`• ${service.service_type || service}: ${service.frequency || ''} ${service.duration || ''}`, this.margin + 5, this.currentY)
        this.currentY += 6
      })
      
      this.currentY += 5
    }

    if (accommodations && Array.isArray(accommodations) && accommodations.length > 0) {
      this.doc.setFontSize(12)
      this.doc.setFont('helvetica', 'bold')
      this.doc.text(this.getTranslation('accommodations'), this.margin, this.currentY)
      this.currentY += 8

      accommodations.forEach((accommodation: any) => {
        this.doc.setFontSize(10)
        this.doc.setFont('helvetica', 'normal')
        const accText = typeof accommodation === 'string' ? accommodation : accommodation.description || accommodation.type
        this.doc.text(`• ${accText}`, this.margin + 5, this.currentY)
        this.currentY += 6
      })
    }

    this.currentY += 10
  }

  private getStatusColor(status: string | undefined): string {
    switch (status) {
      case 'mastered': return COLORS.success
      case 'progressing': return COLORS.primary
      case 'introduced': return COLORS.warning
      case 'not_started': return COLORS.lightText
      default: return COLORS.text
    }
  }

  private checkPageBreak(neededSpace: number = 30) {
    if (this.currentY + neededSpace > this.pageHeight - this.margin) {
      this.doc.addPage()
      this.currentY = this.margin
    }
  }

  public async generatePDF(): Promise<Blob> {
    try {
      // Add header
      this.addHeader()

      // Add student information
      this.checkPageBreak(60)
      this.addStudentInformation()

      // Add program information
      this.checkPageBreak(60)
      this.addProgramInformation()

      // Add goals
      if (this.options.includeGoalDetails) {
        this.checkPageBreak(80)
        this.addGoals()
      }

      // Add progress data
      if (this.options.includeProgress) {
        this.checkPageBreak(100)
        this.addProgressData()
      }

      // Add services and accommodations
      this.checkPageBreak(60)
      this.addServices()

      // Add watermark if specified
      if (this.options.watermark) {
        this.addWatermark(this.options.watermark)
      }

      // Add page numbers and footers
      const totalPages = this.doc.getNumberOfPages()
      for (let i = 1; i <= totalPages; i++) {
        this.doc.setPage(i)
        this.addFooter(i, totalPages)
      }

      // Return PDF as blob
      return this.doc.output('blob')

    } catch (error) {
      console.error('Error generating PDF:', error)
      throw new Error('Failed to generate PDF document')
    }
  }

  private addWatermark(text: string) {
    const totalPages = this.doc.getNumberOfPages()
    
    for (let i = 1; i <= totalPages; i++) {
      this.doc.setPage(i)
      this.doc.setFontSize(50)
      this.doc.setTextColor(200, 200, 200) // Light gray
      this.doc.setFont('helvetica', 'bold')
      
      // Add rotated watermark text
      this.doc.text(text, this.pageWidth / 2, this.pageHeight / 2, {
        align: 'center',
        angle: 45
      })
    }
  }

  public static async exportIEPToPDF(data: PDFExportData): Promise<Blob> {
    const exporter = new IEPPDFExporter(data)
    return await exporter.generatePDF()
  }
}

// Convenience functions for different export types
export const exportFullIEP = async (
  iep: IEP & { student: Student; goals: IEPGoal[]; progress_data?: IEPProgressData[] },
  options: Partial<ExportOptions> = {},
  generatedBy: string = 'System'
): Promise<Blob> => {
  const exportData: PDFExportData = {
    iep,
    exportOptions: {
      language: 'bilingual',
      includeProgress: true,
      includeMeetings: true,
      includeGoalDetails: true,
      includeAssessments: true,
      confidential: true,
      ...options
    },
    generatedBy,
    generatedAt: format(new Date(), 'PPP p')
  }

  return await IEPPDFExporter.exportIEPToPDF(exportData)
}

export const exportProgressReport = async (
  iep: IEP & { student: Student; goals: IEPGoal[]; progress_data?: IEPProgressData[] },
  dateRange: { start: string; end: string },
  options: Partial<ExportOptions> = {},
  generatedBy: string = 'System'
): Promise<Blob> => {
  const exportData: PDFExportData = {
    iep,
    exportOptions: {
      language: 'bilingual',
      includeProgress: true,
      includeMeetings: false,
      includeGoalDetails: true,
      includeAssessments: false,
      dateRange,
      ...options
    },
    generatedBy,
    generatedAt: format(new Date(), 'PPP p')
  }

  return await IEPPDFExporter.exportIEPToPDF(exportData)
}

export const exportGoalSummary = async (
  iep: IEP & { student: Student; goals: IEPGoal[] },
  options: Partial<ExportOptions> = {},
  generatedBy: string = 'System'
): Promise<Blob> => {
  const exportData: PDFExportData = {
    iep,
    exportOptions: {
      language: 'bilingual',
      includeProgress: false,
      includeMeetings: false,
      includeGoalDetails: true,
      includeAssessments: false,
      ...options
    },
    generatedBy,
    generatedAt: format(new Date(), 'PPP p')
  }

  return await IEPPDFExporter.exportIEPToPDF(exportData)
}

// Utility function to download PDF
export const downloadPDF = (blob: Blob, filename: string) => {
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

// Hook for easy integration with React components
export const useIEPExport = () => {
  const exportIEP = async (
    iep: IEP & { student: Student; goals: IEPGoal[]; progress_data?: IEPProgressData[] },
    options: Partial<ExportOptions> = {},
    filename?: string
  ) => {
    try {
      const blob = await exportFullIEP(iep, options)
      const defaultFilename = `IEP_${iep.student.first_name}_${iep.student.last_name}_${format(new Date(), 'yyyy-MM-dd')}.pdf`
      downloadPDF(blob, filename || defaultFilename)
      return true
    } catch (error) {
      console.error('Export failed:', error)
      return false
    }
  }

  const exportProgress = async (
    iep: IEP & { student: Student; goals: IEPGoal[]; progress_data?: IEPProgressData[] },
    dateRange: { start: string; end: string },
    options: Partial<ExportOptions> = {},
    filename?: string
  ) => {
    try {
      const blob = await exportProgressReport(iep, dateRange, options)
      const defaultFilename = `Progress_Report_${iep.student.first_name}_${iep.student.last_name}_${format(new Date(), 'yyyy-MM-dd')}.pdf`
      downloadPDF(blob, filename || defaultFilename)
      return true
    } catch (error) {
      console.error('Export failed:', error)
      return false
    }
  }

  return {
    exportIEP,
    exportProgress,
    exportGoalSummary: async (
      iep: IEP & { student: Student; goals: IEPGoal[] },
      options: Partial<ExportOptions> = {},
      filename?: string
    ) => {
      try {
        const blob = await exportGoalSummary(iep, options)
        const defaultFilename = `Goals_Summary_${iep.student.first_name}_${iep.student.last_name}_${format(new Date(), 'yyyy-MM-dd')}.pdf`
        downloadPDF(blob, filename || defaultFilename)
        return true
      } catch (error) {
        console.error('Export failed:', error)
        return false
      }
    }
  }
}

export default IEPPDFExporter